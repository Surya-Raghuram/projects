# Create your own file extension

Overview
--------
This Project contains a small C++ demo that demonstrates writing and reading a custom binary file format with the `.filey` extension. The source files are `write.cpp` and `read.cpp`.

Files
-----
- `write.cpp` — The C++ code that creates the file `test.filey`, initializes its header, and writes data into it.
- `read.cpp` — The C++ code that reads from the `test.filey` present in the same path.
- `test.filey` — (Not present initially) generated by executing the `write` binary.

Binary format (the on-disk layout)
-----------------------------
This file type uses two structs in raw binary layout:

- Header (`fileHeader`) — total 10 bytes:
  - `signature[6]` — ASCII signature: `"FILEY0"` (6 bytes)
  - `data_size` (`uint32_t`) — size in bytes of the following data block (4 bytes)

- Data record (`fileData`) — total 28 bytes on most hosts:
  - `number` (`int`) — 4 bytes (host `int` representation)
  - `value` (`float`) — 4 bytes (IEEE-754 float on most platforms)
  - `text[20]` (`char[20]`) — fixed-size text buffer (20 bytes)

Function of the project
--------------------
The project operates in two distinct phases: serialization (writing) and deserialization (reading).

1.  **Writing (`write`):** The writer initializes a header struct containing a specific signature (`FILEY0`) which writes the file type and its version.It also calculates the size of the payload. It then writes to the data struct with sample values (an integer, a float, and a string). Using standard file I/O in **binary mode**, it dumps the raw memory bytes of these structs directly to disk to create `test.filey`.
2.  **Reading (`read`):** The reader opens `test.filey` and first ingests only the 10-byte header. It verifies the **signature** against `FILEY0`. If the signature matches, it confirms the file is a valid `.filey` file. It then proceeds to read the specific number of bytes defined in `data_size` directly into a memory structure to retrieve and display the original data.

Build and run
-------------
The project is split into two small programs: one that writes the file (`write`) and one that reads it (`read`). Build and run them from the project folder.

```bash
# compile the writer and run it to create `test.filey`
g++ write.cpp -o write
./write

# compile the reader and run it to read and print `test.filey`
g++ read.cpp -o read
./read
```

Sample output
-------------
Running the compiled write prints something like:

```
---- Writing .filey file ----
Written test.filey successfully!
```
Running the compiled read prints something like this

```
---- Reading .filey file ----
Signature: FILEY0
Data size: 28 bytes
Number: 42
Value: 3.14159
Text: Hello World

✓ Read test.filey
```

Suggested improvements
----------------------
[] Endianness Support: Implement byte-swapping to ensure files created on Little Endian systems work on Big Endian systems.

[] Dynamic Strings: Replace the fixed char[20] buffer with length-prefixed strings to allow text of any size.

[] Checksums: Add a CRC32 or hash to the footer to verify data integrity and detect corruption

Safety and usage
----------------
### Caution: `test.xyz` is a binary file, not a script. Do not attempt to run it as an executable.
- The demo writes `test.xyz` into the current working directory; running multiple times will overwrite the file.

